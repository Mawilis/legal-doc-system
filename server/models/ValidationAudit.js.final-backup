/* eslint-disable */
/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
   ‚ïë                              WILSY OS - SOVEREIGN LEGAL OPERATING SYSTEM                                                               ‚ïë
   ‚ïë                    VALIDATION AUDIT MODEL - FORENSIC IMMUTABLE LEDGER v5.0                                                            ‚ïë
   ‚ïë                                                                                                                                        ‚ïë
   ‚ïë                              "Code that doesn't just store data - it seals history"                                                    ‚ïë
   ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù */

import mongoose from 'mongoose';
import crypto from 'crypto';
import logger from '../utils/logger.js';
import cryptoUtils from '../utils/cryptoUtils.js';

// ============================================================================
// FORENSIC CONSTANTS
// ============================================================================

export const AUDIT_ACTIONS = {
  ID_VALIDATION: 'ID_VALIDATION',
  PASSPORT_VALIDATION: 'PASSPORT_VALIDATION',
  CIPC_VALIDATION: 'CIPC_VALIDATION',
  VAT_VALIDATION: 'VAT_VALIDATION',
  SARS_VALIDATION: 'SARS_VALIDATION',
  TAX_CLEARANCE_VALIDATION: 'TAX_CLEARANCE_VALIDATION',
  LPC_VALIDATION: 'LPC_VALIDATION',
  ADVOCATE_VALIDATION: 'ADVOCATE_VALIDATION',
  NOTARY_VALIDATION: 'NOTARY_VALIDATION',
  CONVEYANCER_VALIDATION: 'CONVEYANCER_VALIDATION',
  COURT_ROLL_VALIDATION: 'COURT_ROLL_VALIDATION',
  CASE_NUMBER_VALIDATION: 'CASE_NUMBER_VALIDATION',
  COURT_ORDER_VALIDATION: 'COURT_ORDER_VALIDATION',
  JURISDICTION_VALIDATION: 'JURISDICTION_VALIDATION',
  LOCATION_VALIDATION: 'LOCATION_VALIDATION',
  POSTAL_CODE_VALIDATION: 'POSTAL_CODE_VALIDATION',
  CITATION_VALIDATION: 'CITATION_VALIDATION',
  POPIA_VALIDATION: 'POPIA_VALIDATION',
  ECT_SIGNATURE_VALIDATION: 'ECT_SIGNATURE_VALIDATION',
  TRUST_ACCOUNT_VALIDATION: 'TRUST_ACCOUNT_VALIDATION',
  FICA_VALIDATION: 'FICA_VALIDATION',
  BUSINESS_DATE_VALIDATION: 'BUSINESS_DATE_VALIDATION',
  SEARCH_QUERY_VALIDATION: 'SEARCH_QUERY_VALIDATION',
  DOCUMENT_METADATA_VALIDATION: 'DOCUMENT_METADATA_VALIDATION',
  EVIDENCE_VALIDATION: 'EVIDENCE_VALIDATION',
  URL_VALIDATION: 'URL_VALIDATION',
  EMAIL_VALIDATION: 'EMAIL_VALIDATION'
};

export const AUDIT_STATUS = {
  SUCCESS: 'SUCCESS',
  FAILURE: 'FAILURE',
  WARNING: 'WARNING',
  PENDING: 'PENDING',
  VERIFIED: 'VERIFIED',
  TAMPERED: 'TAMPERED'
};

export const SEVERITY_LEVELS = {
  CRITICAL: 'CRITICAL',
  HIGH: 'HIGH',
  MEDIUM: 'MEDIUM',
  LOW: 'LOW',
  INFO: 'INFO'
};

export const RETENTION_POLICIES = {
  COMPANIES_ACT_10_YEARS: {
    name: 'COMPANIES_ACT_10_YEARS',
    durationMs: 10 * 365 * 24 * 60 * 60 * 1000,
    legalReference: 'Companies Act 71 of 2008, Section 28'
  },
  POPIA_6_YEARS: {
    name: 'POPIA_6_YEARS',
    durationMs: 6 * 365 * 24 * 60 * 60 * 1000,
    legalReference: 'POPIA Section 19, Section 14'
  },
  ECT_5_YEARS: {
    name: 'ECT_5_YEARS',
    durationMs: 5 * 365 * 24 * 60 * 60 * 1000,
    legalReference: 'ECT Act Section 15, Section 17'
  },
  LPC_PERMANENT: {
    name: 'LPC_PERMANENT',
    durationMs: null,
    legalReference: 'Legal Practice Act 28 of 2014, Section 35'
  },
  FICA_5_YEARS: {
    name: 'FICA_5_YEARS',
    durationMs: 5 * 365 * 24 * 60 * 60 * 1000,
    legalReference: 'FICA Section 24, Section 26'
  }
};

export const DATA_RESIDENCY = {
  ZA: 'ZA',
  EU: 'EU',
  US: 'US',
  UK: 'UK',
  AU: 'AU'
};

// ============================================================================
// PII REDACTION PATTERNS
// ============================================================================

const PII_PATTERNS = [
  { pattern: /idNumber|idnumber|id_no|idno|identityNumber/i, replace: true },
  { pattern: /passport|passportNumber/i, replace: true },
  { pattern: /email|emailAddress/i, replace: true },
  { pattern: /phone|telephone|mobile|cell|contactNumber/i, replace: true },
  { pattern: /bankAccount|accountNumber|bankAcc|account_no/i, replace: true },
  { pattern: /creditCard|cardNumber|cc_no|creditcard/i, replace: true },
  { pattern: /address|street|city|postalCode|postalcode|physicalAddress/i, replace: true },
  { pattern: /ipAddress|userIp|clientIp|remoteAddr/i, replace: true }
];

// ============================================================================
// FORENSIC SCHEMA DEFINITION
// ============================================================================

const validationAuditSchema = new mongoose.Schema({
  auditId: {
    type: String,
    required: true,
    unique: true,
    default: () => cryptoUtils.generateId('audit')
  },
  tenantId: {
    type: String,
    required: true,
    index: true,
    validate: {
      validator: function(v) {
        return /^[a-zA-Z0-9_-]{8,64}$/.test(v);
      },
      message: props => `${props.value} is not a valid tenant ID format`
    }
  },
  action: {
    type: String,
    required: true,
    enum: Object.values(AUDIT_ACTIONS),
    index: true
  },
  status: {
    type: String,
    required: true,
    enum: Object.values(AUDIT_STATUS),
    default: AUDIT_STATUS.SUCCESS
  },
  severity: {
    type: String,
    required: true,
    enum: Object.values(SEVERITY_LEVELS),
    default: SEVERITY_LEVELS.INFO
  },
  resourceType: {
    type: String,
    required: true,
    enum: ['identity', 'business', 'professional', 'court', 'jurisdiction', 
           'document', 'financial', 'evidence', 'system', 'user', 'tenant'],
    index: true
  },
  resourceId: { type: String, index: true },
  resourceVersion: String,
  userId: { type: String, index: true },
  userRole: {
    type: String,
    enum: ['SYSTEM', 'ADMIN', 'MANAGER', 'USER', 'AUDITOR', 'API']
  },
  userIp: String,
  userAgent: String,
  validationType: String,
  validationResult: {
    valid: Boolean,
    errors: { type: [String], default: [] },
    warnings: { type: [String], default: [] }
  },
  validationMetadata: mongoose.Schema.Types.Mixed,
  requestData: { type: mongoose.Schema.Types.Mixed, select: false },
  responseData: { type: mongoose.Schema.Types.Mixed, select: false },
  timestamp: {
    type: Date,
    required: true,
    default: Date.now,
    index: true
  },
  processingTimeMs: Number,
  hash: { type: String, required: true },
  previousHash: String,
  chainPosition: { type: Number, required: true },
  chainVerified: { type: Boolean, default: false },
  signature: String,
  signingKeyId: String,
  retentionPolicy: {
    type: String,
    required: true,
    enum: Object.keys(RETENTION_POLICIES),
    default: 'POPIA_6_YEARS'
  },
  retentionExpiry: { type: Date, index: true },
  dataResidency: {
    type: String,
    required: true,
    enum: Object.values(DATA_RESIDENCY),
    default: DATA_RESIDENCY.ZA
  },
  popiaCompliant: { type: Boolean, default: true },
  piiRedacted: { type: Boolean, default: true },
  sensitiveFields: [String],
  evidenceId: String,
  evidenceHash: String,
  metadata: mongoose.Schema.Types.Mixed,
  tags: { type: [String], index: true },
  source: { type: String, default: 'validation-engine' },
  sourceVersion: String
}, {
  timestamps: true,
  strict: true,
  collection: 'validation_audits'
});

// ============================================================================
// FORENSIC INDEXES
// ============================================================================

validationAuditSchema.index({ tenantId: 1, timestamp: -1 });
validationAuditSchema.index({ tenantId: 1, action: 1, timestamp: -1 });
validationAuditSchema.index({ tenantId: 1, status: 1, timestamp: -1 });
validationAuditSchema.index({ tenantId: 1, resourceType: 1, resourceId: 1 });
validationAuditSchema.index({ tenantId: 1, userId: 1, timestamp: -1 });
validationAuditSchema.index({ tenantId: 1, retentionExpiry: 1 });
validationAuditSchema.index({ retentionExpiry: 1 }, { 
  expireAfterSeconds: 0,
  partialFilterExpression: { retentionExpiry: { $exists: true } }
});
validationAuditSchema.index({ hash: 1 }, { unique: true });
validationAuditSchema.index({ tenantId: 1, chainPosition: 1 });

// ============================================================================
// PRE-VALIDATE HOOK - Sets ALL required fields BEFORE validation
// ============================================================================

validationAuditSchema.pre('validate', async function(next) {
  try {
    if (this.isNew) {
      // Generate audit ID if not provided
      if (!this.auditId) {
        this.auditId = cryptoUtils.generateId('audit');
      }

      // Find the latest entry in this tenant's chain
      const lastEntry = await this.constructor.findOne({ 
        tenantId: this.tenantId 
      }).sort({ chainPosition: -1 });

      // Set chain position and previous hash
      if (lastEntry) {
        this.previousHash = lastEntry.hash;
        this.chainPosition = (lastEntry.chainPosition || 0) + 1;
      } else {
        this.chainPosition = 1;
        this.previousHash = null;
      }

      // Ensure timestamp exists
      if (!this.timestamp) {
        this.timestamp = new Date();
      }

      // Create hash data - MUST include ALL fields that define the entry
      const hashData = {
        auditId: this.auditId,
        tenantId: this.tenantId,
        action: this.action,
        status: this.status,
        severity: this.severity,
        resourceType: this.resourceType,
        resourceId: this.resourceId,
        resourceVersion: this.resourceVersion,
        userId: this.userId,
        userRole: this.userRole,
        timestamp: this.timestamp.toISOString(),
        validationResult: this.validationResult || {},
        previousHash: this.previousHash,
        chainPosition: this.chainPosition,
        retentionPolicy: this.retentionPolicy,
        dataResidency: this.dataResidency
      };

      // Generate deterministic hash with sorted keys
      const canonicalString = JSON.stringify(hashData, Object.keys(hashData).sort());
      this.hash = crypto
        .createHash('sha256')
        .update(canonicalString)
        .digest('hex');

      logger.debug('Hash generated', {
        auditId: this.auditId,
        chainPosition: this.chainPosition,
        hash: this.hash.substring(0, 8) + '...'
      });
    }
    next();
  } catch (error) {
    logger.error('Pre-validate hook error', { error: error.message });
    next(error);
  }
});

// ============================================================================
// PRE-SAVE HOOK - Retention expiry
// ============================================================================

validationAuditSchema.pre('save', function(next) {
  try {
    // Set retention expiry based on policy
    if (this.isNew && !this.retentionExpiry && this.retentionPolicy) {
      const policy = RETENTION_POLICIES[this.retentionPolicy];
      if (policy && policy.durationMs) {
        this.retentionExpiry = new Date(Date.now() + policy.durationMs);
      }
    }
    next();
  } catch (error) {
    logger.error('Pre-save hook error', { error: error.message });
    next(error);
  }
});

// ============================================================================
// INSTANCE METHODS
// ============================================================================

validationAuditSchema.methods.verifyIntegrity = function() {
  try {
    // Recreate the hash data exactly as it was created
    const hashData = {
      auditId: this.auditId,
      tenantId: this.tenantId,
      action: this.action,
      status: this.status,
      severity: this.severity,
      resourceType: this.resourceType,
      resourceId: this.resourceId,
      resourceVersion: this.resourceVersion,
      userId: this.userId,
      userRole: this.userRole,
      timestamp: this.timestamp ? this.timestamp.toISOString() : null,
      validationResult: this.validationResult || {},
      previousHash: this.previousHash,
      chainPosition: this.chainPosition,
      retentionPolicy: this.retentionPolicy,
      dataResidency: this.dataResidency
    };

    const canonicalString = JSON.stringify(hashData, Object.keys(hashData).sort());
    const calculatedHash = crypto
      .createHash('sha256')
      .update(canonicalString)
      .digest('hex');

    const isValid = calculatedHash === this.hash;
    
    logger.debug('Integrity verification', {
      auditId: this.auditId,
      isValid,
      storedHash: this.hash?.substring(0, 8),
      calculatedHash: calculatedHash.substring(0, 8)
    });

    return isValid;
  } catch (error) {
    logger.error('Integrity verification failed', { error: error.message });
    return false;
  }
};

validationAuditSchema.methods.generateEvidence = function() {
  return {
    auditId: this.auditId,
    tenantId: this.tenantId,
    action: this.action,
    status: this.status,
    timestamp: this.timestamp,
    hash: this.hash,
    previousHash: this.previousHash,
    chainPosition: this.chainPosition,
    verification: this.verifyIntegrity() ? 'VERIFIED' : 'TAMPERED',
    verificationTimestamp: new Date().toISOString()
  };
};

validationAuditSchema.methods.redactPII = function() {
  const redacted = JSON.parse(JSON.stringify(this.toObject()));
  
  const redactObject = (obj) => {
    if (!obj || typeof obj !== 'object') return obj;
    
    Object.keys(obj).forEach(key => {
      const isPIIKey = PII_PATTERNS.some(p => p.pattern.test(key));
      
      if (isPIIKey && typeof obj[key] === 'string') {
        obj[key] = '[REDACTED]';
      } else if (typeof obj[key] === 'object') {
        redactObject(obj[key]);
      }
    });
    return obj;
  };

  if (redacted.requestData) redacted.requestData = redactObject(redacted.requestData);
  if (redacted.responseData) redacted.responseData = redactObject(redacted.responseData);
  if (redacted.validationMetadata) redacted.validationMetadata = redactObject(redacted.validationMetadata);

  if (redacted.userIp) {
    const parts = redacted.userIp.split('.');
    redacted.userIp = parts.length === 4 ? `${parts[0]}.${parts[1]}.xxx.xxx` : '[REDACTED]';
  }

  return redacted;
};

// ============================================================================
// STATIC METHODS
// ============================================================================

validationAuditSchema.statics.createAudit = async function(data) {
  try {
    const audit = new this(data);
    await audit.save();
    logger.info('üîê FORENSIC AUDIT CREATED', { auditId: audit.auditId });
    return audit;
  } catch (error) {
    logger.error('‚ùå FORENSIC AUDIT FAILED', { error: error.message });
    throw error;
  }
};

validationAuditSchema.statics.findForTenant = async function(tenantId, filters = {}, options = {}) {
  const query = { tenantId, ...filters };
  const { limit = 100, skip = 0, sort = { timestamp: -1 } } = options;
  return this.find(query).sort(sort).limit(limit).skip(skip).lean();
};

validationAuditSchema.statics.verifyChain = async function(tenantId) {
  logger.info('üîç Verifying forensic chain', { tenantId });
  
  const entries = await this.find({ tenantId }).sort({ chainPosition: 1 }).lean();

  let verified = true;
  const brokenLinks = [];

  for (let i = 0; i < entries.length; i += 1) {
    const entry = entries[i];
    
    // Recreate hash data exactly as it was created
    const hashData = {
      auditId: entry.auditId,
      tenantId: entry.tenantId,
      action: entry.action,
      status: entry.status,
      severity: entry.severity,
      resourceType: entry.resourceType,
      resourceId: entry.resourceId,
      resourceVersion: entry.resourceVersion,
      userId: entry.userId,
      userRole: entry.userRole,
      timestamp: entry.timestamp ? new Date(entry.timestamp).toISOString() : null,
      validationResult: entry.validationResult || {},
      previousHash: entry.previousHash,
      chainPosition: entry.chainPosition,
      retentionPolicy: entry.retentionPolicy,
      dataResidency: entry.dataResidency
    };

    const canonicalString = JSON.stringify(hashData, Object.keys(hashData).sort());
    const calculatedHash = crypto
      .createHash('sha256')
      .update(canonicalString)
      .digest('hex');

    if (calculatedHash !== entry.hash) {
      verified = false;
      brokenLinks.push({
        position: entry.chainPosition,
        auditId: entry.auditId,
        error: 'Hash mismatch - data tampered'
      });
    }

    // Verify link to previous
    if (i > 0 && entry.previousHash !== entries[i - 1].hash) {
      verified = false;
      brokenLinks.push({
        position: entry.chainPosition,
        auditId: entry.auditId,
        error: 'Previous hash mismatch - chain broken'
      });
    }
  }

  logger.info('Chain verification complete', { 
    tenantId, 
    verified, 
    brokenLinks: brokenLinks.length 
  });

  return { verified, entryCount: entries.length, brokenLinks, tenantId };
};

validationAuditSchema.statics.exportEvidence = async function(tenantId, filters = {}) {
  const entries = await this.find({ tenantId, ...filters }).sort({ chainPosition: 1 }).lean();
  const chainVerification = await this.verifyChain(tenantId);
  
  const evidence = {
    tenantId,
    exportId: cryptoUtils.generateId('evidence'),
    exportTimestamp: new Date().toISOString(),
    entryCount: entries.length,
    entries: entries.map(e => ({
      auditId: e.auditId,
      action: e.action,
      status: e.status,
      timestamp: e.timestamp,
      hash: e.hash,
      previousHash: e.previousHash,
      chainPosition: e.chainPosition
    })),
    chainVerification
  };
  
  const hashString = JSON.stringify(evidence.entries);
  evidence.overallHash = crypto.createHash('sha256').update(hashString).digest('hex');
  return evidence;
};

validationAuditSchema.statics.applyRetention = async function() {
  const now = new Date();
  const result = await this.deleteMany({ retentionExpiry: { $lte: now } });
  logger.info('üßπ Retention policy applied', { deletedCount: result.deletedCount });
  return result;
};

// ============================================================================
// VIRTUAL PROPERTIES
// ============================================================================

validationAuditSchema.virtual('ageInDays').get(function() {
  return Math.floor((Date.now() - this.timestamp) / (24 * 60 * 60 * 1000));
});

validationAuditSchema.virtual('isExpired').get(function() {
  return this.retentionExpiry && this.retentionExpiry < new Date();
});

validationAuditSchema.virtual('summary').get(function() {
  return {
    auditId: this.auditId,
    action: this.action,
    status: this.status,
    timestamp: this.timestamp,
    resourceType: this.resourceType,
    valid: this.validationResult?.valid,
    chainPosition: this.chainPosition,
    integrity: this.verifyIntegrity() ? 'INTACT' : 'TAMPERED'
  };
});

// ============================================================================
// MODEL CREATION
// ============================================================================

const ValidationAudit = mongoose.model('ValidationAudit', validationAuditSchema);

export default ValidationAudit;
